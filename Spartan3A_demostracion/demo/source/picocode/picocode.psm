;;============================================================================
;; Copyright (c) 2006 Xilinx, Inc.
;; This design is confidential and proprietary of Xilinx, All Rights Reserved.
;;============================================================================
;;   ____  ____
;;  /   /\/   /
;; /___/  \  /   Vendor:        Xilinx
;; \   \   \/    Version:       1.0.0
;;  \   \        Filename:      picocode.psm
;;  /   /        Date Created:  December 25, 2006
;; /___/   /\    Last Modified: December 25, 2006
;; \   \  /  \
;;  \___\/\___\
;;
;; Devices:   Spartan-3 Generation FPGA
;; Purpose:   Board demo controller program
;; Contact:   crabill@xilinx.com
;; Reference: Borrowed pieces from Spartan-3E Starter Kit Reference Designs
;;
;; Revision History:
;;   Rev 1.0.0 - (crabill) First created December 25, 2006.
;;
;;============================================================================
;;
;; LIMITED WARRANTY AND DISCLAIMER. These designs are provided to you "as is".
;; Xilinx and its licensors make and you receive no warranties or conditions,
;; express, implied, statutory or otherwise, and Xilinx specifically disclaims
;; any implied warranties of merchantability, non-infringement, or fitness for
;; a particular purpose. Xilinx does not warrant that the functions contained
;; in these designs will meet your requirements, or that the operation of
;; these designs will be uninterrupted or error free, or that defects in the
;; designs will be corrected. Furthermore, Xilinx does not warrant or make any
;; representations regarding use or the results of the use of the designs in
;; terms of correctness, accuracy, reliability, or otherwise.
;;
;; LIMITATION OF LIABILITY. In no event will Xilinx or its licensors be liable
;; for any loss of data, lost profits, cost or procurement of substitute goods
;; or services, or for any special, incidental, consequential, or indirect
;; damages arising from the use or operation of the designs or accompanying
;; documentation, however caused and on any theory of liability. This
;; limitation will apply even if Xilinx has been advised of the possibility
;; of such damage. This limitation shall apply not-withstanding the failure
;; of the essential purpose of any limited remedies herein.
;;
;;============================================================================
;; Copyright (c) 2006 Xilinx, Inc.
;; This design is confidential and proprietary of Xilinx, All Rights Reserved.
;;============================================================================

CONSTANT ascii_CR         , 0D    ; ascii code

CONSTANT ascii_SPACE      , 20    ; ascii code
CONSTANT ascii_EXCLAIM    , 21    ; ascii code
CONSTANT ascii_DBLQUOT    , 22    ; ascii code
CONSTANT ascii_NUMSIGN    , 23    ; ascii code
CONSTANT ascii_DOLLAR     , 24    ; ascii code
CONSTANT ascii_PERCENT    , 25    ; ascii code
CONSTANT ascii_AMP        , 26    ; ascii code
CONSTANT ascii_SINQUOT    , 27    ; ascii code
CONSTANT ascii_LPAREN     , 28    ; ascii code
CONSTANT ascii_RPAREN     , 29    ; ascii code
CONSTANT ascii_ASTERISK   , 2A    ; ascii code
CONSTANT ascii_PLUS       , 2B    ; ascii code
CONSTANT ascii_COMMA      , 2C    ; ascii code
CONSTANT ascii_MINUS      , 2D    ; ascii code
CONSTANT ascii_PERIOD     , 2E    ; ascii code
CONSTANT ascii_FWDSLASH   , 2F    ; ascii code

CONSTANT ascii_0          , 30    ; ascii code
CONSTANT ascii_1          , 31    ; ascii code
CONSTANT ascii_2          , 32    ; ascii code
CONSTANT ascii_3          , 33    ; ascii code
CONSTANT ascii_4          , 34    ; ascii code
CONSTANT ascii_5          , 35    ; ascii code
CONSTANT ascii_6          , 36    ; ascii code
CONSTANT ascii_7          , 37    ; ascii code
CONSTANT ascii_8          , 38    ; ascii code
CONSTANT ascii_9          , 39    ; ascii code
CONSTANT ascii_COLON      , 3A    ; ascii code
CONSTANT ascii_SEMI       , 3B    ; ascii code
CONSTANT ascii_LESS       , 3C    ; ascii code
CONSTANT ascii_EQUAL      , 3D    ; ascii code
CONSTANT ascii_GREATER    , 3E    ; ascii code
CONSTANT ascii_QUESTION   , 3F    ; ascii code

CONSTANT ascii_CIRCAT     , 40    ; ascii code
CONSTANT ascii_A          , 41    ; ascii code
CONSTANT ascii_B          , 42    ; ascii code
CONSTANT ascii_C          , 43    ; ascii code
CONSTANT ascii_D          , 44    ; ascii code
CONSTANT ascii_E          , 45    ; ascii code
CONSTANT ascii_F          , 46    ; ascii code
CONSTANT ascii_G          , 47    ; ascii code
CONSTANT ascii_H          , 48    ; ascii code
CONSTANT ascii_I          , 49    ; ascii code
CONSTANT ascii_J          , 4A    ; ascii code
CONSTANT ascii_K          , 4B    ; ascii code
CONSTANT ascii_L          , 4C    ; ascii code
CONSTANT ascii_M          , 4D    ; ascii code
CONSTANT ascii_N          , 4E    ; ascii code
CONSTANT ascii_O          , 4F    ; ascii code

CONSTANT ascii_P          , 50    ; ascii code
CONSTANT ascii_Q          , 51    ; ascii code
CONSTANT ascii_R          , 52    ; ascii code
CONSTANT ascii_S          , 53    ; ascii code
CONSTANT ascii_T          , 54    ; ascii code
CONSTANT ascii_U          , 55    ; ascii code
CONSTANT ascii_V          , 56    ; ascii code
CONSTANT ascii_W          , 57    ; ascii code
CONSTANT ascii_X          , 58    ; ascii code
CONSTANT ascii_Y          , 59    ; ascii code
CONSTANT ascii_Z          , 5A    ; ascii code
CONSTANT ascii_LBKT       , 5B    ; ascii code
CONSTANT ascii_BKSLASH    , 5C    ; ascii code
CONSTANT ascii_RBKT       , 5D    ; ascii code
CONSTANT ascii_CARET      , 5E    ; ascii code
CONSTANT ascii_DASH       , 5F    ; ascii code

CONSTANT ascii_TICK       , 60    ; ascii code
CONSTANT ascii_a          , 61    ; ascii code
CONSTANT ascii_b          , 62    ; ascii code
CONSTANT ascii_c          , 63    ; ascii code
CONSTANT ascii_d          , 64    ; ascii code
CONSTANT ascii_e          , 65    ; ascii code
CONSTANT ascii_f          , 66    ; ascii code
CONSTANT ascii_g          , 67    ; ascii code
CONSTANT ascii_h          , 68    ; ascii code
CONSTANT ascii_i          , 69    ; ascii code
CONSTANT ascii_j          , 6A    ; ascii code
CONSTANT ascii_k          , 6B    ; ascii code
CONSTANT ascii_l          , 6C    ; ascii code
CONSTANT ascii_m          , 6D    ; ascii code
CONSTANT ascii_n          , 6E    ; ascii code
CONSTANT ascii_o          , 6F    ; ascii code

CONSTANT ascii_p          , 70    ; ascii code
CONSTANT ascii_q          , 71    ; ascii code
CONSTANT ascii_r          , 72    ; ascii code
CONSTANT ascii_s          , 73    ; ascii code
CONSTANT ascii_t          , 74    ; ascii code
CONSTANT ascii_u          , 75    ; ascii code
CONSTANT ascii_v          , 76    ; ascii code
CONSTANT ascii_w          , 77    ; ascii code
CONSTANT ascii_x          , 78    ; ascii code
CONSTANT ascii_y          , 79    ; ascii code
CONSTANT ascii_z          , 7A    ; ascii code

;;============================================================================
;; Ports and related constants.
;;============================================================================

CONSTANT pt_master_ctrl_l , 00    ; port master_ctrl_l
CONSTANT pt_master_ctrl_h , 01    ; port master_ctrl_h
CONSTANT pt_match_val_l   , 02    ; port match_val_l
CONSTANT pt_match_val_h   , 03    ; port match_val_h
CONSTANT pt_view_x_apos   , 04    ; port view_x_apos
CONSTANT pt_view_y_apos   , 05    ; port view_y_apos
CONSTANT pt_view_access   , 06    ; port view_access
CONSTANT pt_view_params   , 07    ; port view_params

CONSTANT pt_view_x_orig   , 08    ; port view_x_orig
CONSTANT pt_view_x_size   , 09    ; port view_x_size
CONSTANT pt_view_y_orig   , 0A    ; port view_y_orig
CONSTANT pt_view_y_size   , 0B    ; port view_y_size
CONSTANT pt_view_cptr_l   , 0C    ; port view_cptr_l
CONSTANT pt_view_cptr_h   , 0D    ; port view_cptr_h
CONSTANT pt_view_fptr_l   , 0E    ; port view_fptr_l
CONSTANT pt_view_fptr_h   , 0F    ; port view_fptr_h

CONSTANT clr_dis_auto     , 87    ; clear & dis intr, autoinc on
CONSTANT vmatch_ena_auto  , E7    ; clear & ena vmatch, autoinc on
CONSTANT disp_dis_msk     , 7F    ; display disable mask
CONSTANT default_xy_size  , 1F    ; power'o'two minus one

CONSTANT rs232dce_data    , 20    ; port for data read and write
CONSTANT rs232dce_stat    , 21    ; read port for status
CONSTANT rs232dce_rxpres  , 01    ; rx fifo pres
CONSTANT rs232dce_rxfull  , 08    ; rx fifo full
CONSTANT rs232dce_txfull  , 10    ; tx fifo full
CONSTANT rs232dce_txpres  , 80    ; tx fifo pres

CONSTANT lcd_dout         , 22    ; port for 8-bit lcd data out
CONSTANT lcd_ctrl         , 23    ; port for lcd control
CONSTANT lcd_e            , 01    ; active high enable
CONSTANT lcd_rw           , 02    ; read = 1, write = 0
CONSTANT lcd_rs           , 04    ; instruction = 0, data = 1

CONSTANT sws_stat         , 24    ; read switches, read only
CONSTANT btn_stat         , 25    ; read buttons, read only
CONSTANT btn_stat_n       , 08    ; button n press
CONSTANT btn_stat_e       , 04    ; button e press
CONSTANT btn_stat_s       , 02    ; button s press
CONSTANT btn_stat_w       , 01    ; button w press
CONSTANT rot_stat         , 26    ; knob events, write clears
CONSTANT rot_stat_up      , 08    ; knob popped up
CONSTANT rot_stat_dn      , 04    ; knob pressed dn
CONSTANT rot_stat_lt      , 02    ; knob turned ccw
CONSTANT rot_stat_rt      , 01    ; knob turned cw
CONSTANT led_stat         , 27    ; led control

CONSTANT rz_enable        , 28    ; rz enable control
CONSTANT rz_enable_on     , 01    ; rz on
CONSTANT rz_enable_off    , 00    ; rz off

CONSTANT rz_clutmode      , 29    ; select image
CONSTANT rz_clutmode_img0 , 00    ; data [1:0]
CONSTANT rz_clutmode_img1 , 01    ; data [3:2]
CONSTANT rz_clutmode_img2 , 02    ; data [5:4]
CONSTANT rz_clutmode_img3 , 03    ; data [7:6]

CONSTANT rz_angle         , 2A    ; angle output
CONSTANT rz_angle_rst     , 00    ; reset value
CONSTANT rz_step          , 2B    ; step output
CONSTANT rz_step_rst      , 01    ; reset value
CONSTANT rz_dx_frc_ms     , 2C    ; dx fraction
CONSTANT rz_dx_int_ls     , 2D    ; dx integer
CONSTANT rz_dy_frc_ms     , 2E    ; dy fraction
CONSTANT rz_dy_int_ls     , 2F    ; dy integer

CONSTANT rz_xpos_frc_ms   , 31    ; xpos fraction ms byte
CONSTANT rz_xpos_int_ls   , 32    ; xpos integer ls byte
CONSTANT rz_xpos_int_ms   , 33    ; xpos integer ms byte
CONSTANT rz_ypos_frc_ms   , 35    ; xpos fraction ms byte
CONSTANT rz_ypos_int_ls   , 36    ; xpos integer ls byte
CONSTANT rz_ypos_int_ms   , 37    ; xpos integer ms byte
CONSTANT rz_xdel_frc_ms   , 39    ; xdel fraction ms byte
CONSTANT rz_xdel_int_ls   , 3A    ; xdel integer ls byte
CONSTANT rz_ydel_frc_ms   , 3D    ; xdel fraction ms byte
CONSTANT rz_ydel_int_ls   , 3E    ; xdel integer ls byte

CONSTANT mb_ad_ll         , 40    ; multiboot address 0
CONSTANT mb_ad_ml         , 41    ; multiboot address 1
CONSTANT mb_ad_mh         , 42    ; multiboot address 2
CONSTANT mb_ad_hh         , 43    ; multiboot address 3
CONSTANT mb_mode          , 44    ; multiboot mode
CONSTANT mb_vsel          , 45    ; multiboot vsel
CONSTANT mb_iuse          , 46    ; multiboot iuse
CONSTANT mb_strobe        , 47    ; multiboot strobe
CONSTANT mb_max           , 04    ; up to max val
CONSTANT mb_cfg_vsel      , 07    ; vsel
CONSTANT mb_cfg_ad_hh     , 03    ; spi read cmd

;; If the configuration device uses linear addressing
;; you would use the destination bitstream address as
;; the 24-bit address value for multiboot.  This design
;; uses a configuration device with page/byte address
;; which makes things more complicated.  Consider a
;; bitstream which starts at "linear address" 0x060000
;; (393216) as specified to the promgen application.
;; The device has a page size of 528 bytes, and a byte
;; is addressed as 00_pppppppppppp_bbbbbbbbbb where p
;; is a page address bit and b is a byte address bit.
;;
;; page address = 393216 div 528 =  744 = 001011101000
;; byte address = 393216 mod 528 =  384 =   0110000000
;;
;; multiboot to 0b00_001011101000_0110000000 = 0x0BA180

CONSTANT mb_cfg1_ad_ll    , 80    ; address [ 7: 0] code for
CONSTANT mb_cfg1_ad_ml    , A1    ; address [15: 8] "address"
CONSTANT mb_cfg1_ad_mh    , 0B    ; address [23:16] 0x060000

;; If the configuration device uses linear addressing
;; you would use the destination bitstream address as
;; the 24-bit address value for multiboot.  This design
;; uses a configuration device with page/byte address
;; which makes things more complicated.  Consider a
;; bitstream which starts at "linear address" 0x0C0000
;; (786432) as specified to the promgen application.
;; The device has a page size of 528 bytes, and a byte
;; is addressed as 0b00_pppppppppppp_bbbbbbbbbb where
;; p is a page address bit and b is a byte address bit.
;;
;; page address = 786432 div 528 = 1489 = 010111010001
;; byte address = 786432 mod 528 =  240 =   0011110000
;;
;; multiboot 0b00_010111010001_0011110000 = 0x1744F0

CONSTANT mb_cfg2_ad_ll    , F0    ; address [ 7: 0] code for
CONSTANT mb_cfg2_ad_ml    , 44    ; address [15: 8] "address"
CONSTANT mb_cfg2_ad_mh    , 17    ; address [23:16] 0x0C0000

;; If the configuration device uses linear addressing
;; you would use the destination bitstream address as
;; the 24-bit address value for multiboot.  This design
;; uses a configuration device with page/byte address
;; which makes things more complicated.  Consider a
;; bitstream which starts at "linear address" 0x120000
;; (1179648) as specified to the promgen application.
;; The device has a page size of 528 bytes, and a byte
;; is addressed as 00_pppppppppppp_bbbbbbbbbb where p
;; is a page address bit and b is a byte address bit.
;;
;; page address = 1179648 div 528 = 2234 = 100010111010
;; byte address = 1179648 mod 528 =   96 =   0001100000
;;
;; multiboot to 0b00_100010111010_0001100000 = 0x22E860 

CONSTANT mb_cfg3_ad_ll    , 60    ; address [ 7: 0] code for
CONSTANT mb_cfg3_ad_ml    , E8    ; address [15: 8] "address"
CONSTANT mb_cfg3_ad_mh    , 22    ; address [23:16] 0x120000

;; If the configuration device uses linear addressing
;; you would use the destination bitstream address as
;; the 24-bit address value for multiboot.  This design
;; uses a configuration device with page/byte address
;; which makes things more complicated.  Consider a
;; bitstream which starts at "linear address" 0x180000
;; (1572864) as specified to the promgen application.
;; The device has a page size of 528 bytes, and a byte
;; is addressed as 0b00_pppppppppppp_bbbbbbbbbb where
;; p is a page address bit and b is a byte address bit.
;;
;; page address = 1572864 div 528 = 2978 = 101110100010
;; byte address = 1572864 mod 528 =  480 =   0111100000
;;
;; multiboot 0b00_101110100010_0111100000 = 0x2E89E0 

CONSTANT mb_cfg4_ad_ll    , E0    ; address [ 7: 0] code for
CONSTANT mb_cfg4_ad_ml    , 89    ; address [15: 8] "address"
CONSTANT mb_cfg4_ad_mh    , 2E    ; address [23:16] 0x180000

CONSTANT audio_volume     , 48    ; audio volume control
CONSTANT audio_vol_max    , 07    ; audio max value
CONSTANT audio_vol_min    , 00    ; audio min value
CONSTANT audio_loop       , 49    ; audio loop value
CONSTANT audio_loop_1a    , 00    ; audio 1, vocals
CONSTANT audio_loop_1b    , 01    ; audio 1, instrumental
CONSTANT audio_loop_2a    , 02    ; audio 2, vocals
CONSTANT audio_loop_2b    , 03    ; audio 2, instrumental
CONSTANT audio_message    , 04    ; audio 3, message
CONSTANT audio_novox      , 01    ; instrumental only
CONSTANT audio_novoxpct   , 0B    ; novox ((val+1)/16)%
CONSTANT audio_rand_msk   , 0F    ; random mask
CONSTANT audio_enable     , 4A    ; audio enable
CONSTANT audio_stat       , 4B    ; audio status

CONSTANT auto_addr_l      , 4C    ; autopilot low address
CONSTANT auto_addr_h      , 4D    ; autopilot high address
CONSTANT auto_data        , 4E    ; autopilot data
CONSTANT auto_flag        , 4F    ; autopilot flag
CONSTANT auto_flag_on     , 80    ; enabled bit
CONSTANT auto_lcddone     , 40    ; lcd hello done
CONSTANT auto_reset       , 80    ; how to begin

CONSTANT manu_rot_step    , 08    ; step size for knob
CONSTANT auto_rot_step    , 01    ; step size for auto

CONSTANT hwc_xpos_l       , 50    ; cursor xpos lo
CONSTANT hwc_xpos_h       , 51    ; cursor xpos hi
CONSTANT hwc_ypos_l       , 52    ; cursor ypos lo
CONSTANT hwc_ypos_h       , 53    ; cursor ypos hi

;;============================================================================
;; Other constants.
;;============================================================================

;; Constant to define a software delay of 1us. This must be adjusted
;; to reflect the clock period. Every instruction executes in 2 cycles.
;; delay_1us_constant = (clock_rate - 6)/4, where 'clock_rate' is in
;; MHz.  Example: For 25MHz clock the constant value is (25-6)/4 = 5.

CONSTANT delay_1us_const  , 05    ; delay 1 us value

CONSTANT terminal_lines   , 18    ; hyperterm line count

CONSTANT zero             , 00    ; zero
CONSTANT one              , 01    ; one
CONSTANT minus_one        , FF    ; minus one
CONSTANT ascii_adj        , 30    ; number conversions

CONSTANT control_state0   , 00    ; state 0
CONSTANT control_state1   , 01    ; state 1
CONSTANT control_state2   , 02    ; state 2
CONSTANT control_state3   , 03    ; state 3
CONSTANT control_mask     , 03    ; mask

CONSTANT band_max         , 06    ; implement counter rollover

;;============================================================================
;; This is the picotext display list and related constants.
;;============================================================================

CONSTANT band0_vmatch_l   , E0    ; (2*8) - 1 equals 000F but used
CONSTANT band0_vmatch_h   , 01    ; 01E0 for start of vblnk interval
CONSTANT band0_cptr_l     , 00    ; start of
CONSTANT band0_cptr_h     , 04    ; string
CONSTANT band0_params     , 27    ; red on white
CONSTANT band0_x_size     , 1F    ; 32 chars rel
CONSTANT band0_y_size     , 01    ; 2 chars rel
CONSTANT band0_x_orig     , 00    ; 00 chars abs
CONSTANT band0_y_orig     , 02    ; 2 chars abs

CONSTANT band1_vmatch_l   , 3F    ; (8*8) - 1 
CONSTANT band1_vmatch_h   , 00    ; equals 003F
CONSTANT band1_cptr_l     , C0    ; start of
CONSTANT band1_cptr_h     , 07    ; string
CONSTANT band1_params     , 07    ; black on white
CONSTANT band1_x_size     , 1F    ; 32 chars rel
CONSTANT band1_y_size     , 05    ; 6 chars rel
CONSTANT band1_x_orig     , 00    ; 00 chars abs
CONSTANT band1_y_orig     , 08    ; 8 chars abs

CONSTANT band2_vmatch_l   , 8F    ; (18*8) - 1 
CONSTANT band2_vmatch_h   , 00    ; equals 007F
CONSTANT band2_cptr_l     , 80    ; start of
CONSTANT band2_cptr_h     , 05    ; string
CONSTANT band2_params     , 07    ; black on white
CONSTANT band2_x_size     , 1F    ; 32 chars rel
CONSTANT band2_y_size     , 05    ; 6 chars rel
CONSTANT band2_x_orig     , 00    ; 00 chars abs
CONSTANT band2_y_orig     , 12    ; 18 chars abs

CONSTANT band3_vmatch_l   , DF    ; (28*8) - 1 
CONSTANT band3_vmatch_h   , 00    ; equals 00DF
CONSTANT band3_cptr_l     , 40    ; start of
CONSTANT band3_cptr_h     , 04    ; string
CONSTANT band3_params     , 07    ; black on white
CONSTANT band3_x_size     , 1F    ; 32 chars rel
CONSTANT band3_y_size     , 00    ; 1 chars rel
CONSTANT band3_x_orig     , 00    ; 00 chars abs
CONSTANT band3_y_orig     , 1C    ; 28 chars abs

CONSTANT band4_vmatch_l   , 07    ; (33*8) - 1 
CONSTANT band4_vmatch_h   , 01    ; equals 0107
CONSTANT band4_cptr_l     , 60    ; start of
CONSTANT band4_cptr_h     , 04    ; string
CONSTANT band4_params     , 07    ; black on white
CONSTANT band4_x_size     , 1F    ; 32 chars rel
CONSTANT band4_y_size     , 06    ; 7 chars rel
CONSTANT band4_x_orig     , 00    ; 00 chars abs
CONSTANT band4_y_orig     , 21    ; 33 chars abs

CONSTANT band5_vmatch_l   , 67    ; (45*8) - 1 
CONSTANT band5_vmatch_h   , 01    ; equals 0167
CONSTANT band5_cptr_l     , 40    ; start of
CONSTANT band5_cptr_h     , 05    ; string
CONSTANT band5_params     , 27    ; red on white
CONSTANT band5_x_size     , 1F    ; 32 chars rel
CONSTANT band5_y_size     , 01    ; 2 chars rel
CONSTANT band5_x_orig     , 00    ; 00 chars abs
CONSTANT band5_y_orig     , 2D    ; 45 chars abs

CONSTANT band6_vmatch_l   , 9F    ; (52*8) - 1 
CONSTANT band6_vmatch_h   , 01    ; equals 019F
CONSTANT band6a_cptr_l    , 40    ; start of
CONSTANT band6a_cptr_h    , 06    ; string
CONSTANT band6b_cptr_l    , A0    ; start of
CONSTANT band6b_cptr_h    , 06    ; string
CONSTANT band6c_cptr_l    , 00    ; start of
CONSTANT band6c_cptr_h    , 07    ; string
CONSTANT band6d_cptr_l    , 60    ; start of
CONSTANT band6d_cptr_h    , 07    ; string
CONSTANT band6_params     , 0F    ; blue on white
CONSTANT band6_x_size     , 1F    ; 32 chars rel
CONSTANT band6_y_size     , 02    ; 3 chars rel
CONSTANT band6_x_orig     , 18    ; 24 chars abs
CONSTANT band6_y_orig     , 34    ; 52 chars abs

CONSTANT list_cptr_l      , 80    ; display list
CONSTANT list_cptr_h      , 08    ; start address

;; For run-time string changes in band6 on the
;; display, we simply change the pointer to the
;; string in the band6 display list entry.  This
;; is stored at list_cptr + 3Dh

CONSTANT b6_cptr_offset   , 3D    ; offset to ptr

;; For run-time string changes in band6d on the
;; display, we can also change the string itself
;; as stored in the buffer.  This offset is to
;; the configuration number in string band6d,
;; which is stored at band6d_cptr + 1Eh

CONSTANT b6d_num_offset  , 1E     ; offset to char

;; Pointer and length information for ascii string
;; stored in the picotext display buffer, which is
;; meant to be read out and sent to the serial port.

CONSTANT dce_msg_ptr_l    , E0    ; offset to msg
CONSTANT dce_msg_ptr_h    , 0C    ; offset to msg
CONSTANT dce_msg_len_l    , 94    ; msg length - 1
CONSTANT dce_msg_len_h    , 02    ; msg length - 1

;;============================================================================
;; Start up routine goes here.
;;
;; Register usage convention is:
;; * s0, s1, s2, s3, s4, and s5 are are for general
;;   use in the main program loop.
;; * s7 is reserved for multiboot select variable.
;; * s8 is reserved for display state variable.
;; * s6, s9, sA, sB, sC, sD, sE are for general use
;;   in the interrupt service routine.
;; * sF is reserved for the control state variable.
;;============================================================================

      cold_start: LOAD s0, clr_dis_auto               ; intr clr and disable
                  OUTPUT s0, pt_master_ctrl_h         ; write master_ctrl_h
                  LOAD s0, zero                       ; disable and zero loop
                  OUTPUT s0, audio_enable             ; write to hardware
                  LOAD s0, audio_vol_max              ; get initial volume
                  OUTPUT s0, audio_volume             ; write to hardware
                  LOAD s0, audio_message              ; use audio_loop_1a to
                  OUTPUT s0, audio_loop               ; optionally skip msg
                  OUTPUT s0, hwc_xpos_l               ; zero out
                  OUTPUT s0, hwc_ypos_l               ; zero out
                  LOAD s0, minus_one                  ; big number
                  OUTPUT s0, hwc_xpos_h               ; set all bits
                  OUTPUT s0, hwc_ypos_h               ; set all bits
                  LOAD s0, rz_enable_on               ; enable rotozoomer
                  OUTPUT s0, rz_enable                ; write rotozoomer ctrl
                  LOAD s0, rz_angle_rst               ; load default angle
                  OUTPUT s0, rz_angle                 ; and write to rzoom
                  LOAD s0, rz_step_rst                ; load default step
                  OUTPUT s0, rz_step                  ; and write to rzoom
                  LOAD s0, rz_clutmode_img0           ; load initial image
                  OUTPUT s0, rz_clutmode              ; and write to clutmode
                  LOAD s0, zero                       ; clear out the position
                  OUTPUT s0, rot_stat                 ; clear control events
                  OUTPUT s0, led_stat                 ; and blank the leds
                  OUTPUT s0, rz_xpos_frc_ms           ; write to register
                  OUTPUT s0, rz_xpos_int_ls           ; write to register
                  OUTPUT s0, rz_xpos_int_ms           ; write to register
                  OUTPUT s0, rz_ypos_frc_ms           ; write to register
                  OUTPUT s0, rz_ypos_int_ls           ; write to register
                  OUTPUT s0, rz_ypos_int_ms           ; write to register
                  OUTPUT s0, auto_addr_l              ; write to register
                  OUTPUT s0, auto_addr_h              ; write to register
                  LOAD s0, auto_reset                 ; autopilot, welcome
                  OUTPUT s0, auto_flag                ; write to register

                  ;; This pulls data out of the picotext
                  ;; display buffer and sends it to the
                  ;; serial port.  This has to be done
                  ;; before the display interrupt enable
                  ;; to prevent corrupting the display.

        dump_dce: LOAD s0, default_xy_size            ; set up for autoinc
                  OUTPUT s0, pt_view_x_size           ; write non-zero to size
                  OUTPUT s0, pt_view_y_size           ; so autoinc will work
                  LOAD s0, zero                       ; want offset from cptr zero
                  OUTPUT s0, pt_view_x_apos           ; write to address position
                  OUTPUT s0, pt_view_y_apos           ; offset from cptr is set
                  LOAD s0, dce_msg_ptr_l              ; address where we want
                  OUTPUT s0, pt_view_cptr_l           ; to start pulling data
                  LOAD s0, dce_msg_ptr_h              ; address where we want
                  OUTPUT s0, pt_view_cptr_h           ; to start pulling data
                  LOAD s2, dce_msg_len_l              ; load message length
                  LOAD s3, dce_msg_len_h              ; load message lenght
        dce_loop: INPUT s0, pt_view_access            ; read with autoinc
                  CALL tx_to_dce                      ; ship it out dce
                  SUB s2, one                         ; decrement length
                  SUBCY s3, zero                      ; and check for end
                  JUMP NC, dce_loop                   ; loop while pos/zero

                  ;; Initialize the LCD for use.  The
                  ;; messages displayed on the LCD are
                  ;; context sensitive and set in the
                  ;; main loop of the program.

        init_lcd: CALL lcd_reset_8bit                 ; initialize the lcd

                  ;; Smarter way to preload buffer is to use the
                  ;; BlockRAM INIT strings.  This starts writing
                  ;; the display list to the buffer.  In the final
                  ;; implementation, this code should be removed
                  ;; in favor of a pre-loaded BlockRAM.

        displist: LOAD s0, default_xy_size            ; power of two minus one
                  OUTPUT s0, pt_view_x_size           ; write non-zero to size
                  OUTPUT s0, pt_view_y_size           ; so autoinc will work
                  LOAD s0, zero                       ; want offset from cptr zero
                  OUTPUT s0, pt_view_x_apos           ; write to address position
                  OUTPUT s0, pt_view_y_apos           ; offset from cptr is set
                  LOAD s0, list_cptr_l                ; address where we want
                  OUTPUT s0, pt_view_cptr_l           ; display list to start
                  LOAD s0, list_cptr_h                ; address where we want
                  OUTPUT s0, pt_view_cptr_h           ; display list to start

                  LOAD     s0, band1_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_cptr_l           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_cptr_h           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc

                  LOAD     s0, band2_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_cptr_l           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band1_cptr_h           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc

                  LOAD     s0, band3_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_cptr_l           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band2_cptr_h           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc

                  LOAD     s0, band4_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_cptr_l           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band3_cptr_h           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc

                  LOAD     s0, band5_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_cptr_l           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band4_cptr_h           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc

                  LOAD     s0, band6_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_cptr_l           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band5_cptr_h           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc

                  LOAD     s0, band0_vmatch_l         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band0_vmatch_h         ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6_params           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6_x_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6_y_orig           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6_x_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6_y_size           ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6a_cptr_l          ; load data
                  OUTPUT   s0, pt_view_access         ; write with autoinc
                  LOAD     s0, band6a_cptr_h          ; load data
        end_list: OUTPUT   s0, pt_view_access         ; write with autoinc

       init_intr: LOAD s8, band_max                   ; set band to last
                  LOAD sF, control_state3             ; control state to three
                  LOAD s7, one                        ; multiboot sel to min
                  LOAD s0, band0_vmatch_l             ; next band lo vmatch
                  OUTPUT s0, pt_match_val_l           ; write match_val_l
                  LOAD s0, band0_vmatch_h             ; next band hi vmatch
                  OUTPUT s0, pt_match_val_h           ; write match_val_h
                  LOAD s0, vmatch_ena_auto            ; trigger for next band
                  OUTPUT s0, pt_master_ctrl_h         ; write master_ctrl_h

      display_on: INPUT s0, pt_master_ctrl_l          ; get master_ctrl_l
                  AND s0, disp_dis_msk                ; clear disp disable
                  OUTPUT s0, pt_master_ctrl_l         ; write master_ctrl_l
                  ENABLE INTERRUPT                    ; enable interrupts

;;============================================================================
;; Main program loop; for the most part, this continuously updates the LCD.
;; Everything else is done in the interrupt service routine.
;;============================================================================

       main_loop: INPUT s0, auto_flag                 ; check autopilot
                  TEST s0, auto_lcddone               ; showing welcome?
                  JUMP NZ, based_on_cs                ; otherwise use ctrls
                  CALL lcd_hello                      ; transmit welcome
                  JUMP main_loop                      ; rinse and repeat

     based_on_cs: COMPARE sF, control_state3          ; check control state
                  JUMP Z, mb_time                     ; for mb user interface
                  CALL lcd_pkx                        ; display pkx on lcd
                  CALL lcd_fbm                        ; display fbm on lcd
                  JUMP main_loop                      ; rinse and repeat

         mb_time: CALL lcd_blc                        ; display blc on lcd
                  CALL lcd_ssc                        ; display ssc on lcd
                  JUMP main_loop                      ; rinse and repeat

;;============================================================================
;; Interrupt service routine; this is responsible for keeping the display
;; running.  At the end of each frame, the isr also processes user inputs.
;;============================================================================

       isr_start: COMPARE s8, band_max                ; compare current to max
                  JUMP NZ, band_incr                  ; if not equal, increment
                  CALL process_ctrls                  ; process controls in vblank
                  LOAD s8, minus_one                  ; else minus one to roll
       band_incr: ADD s8, one                         ; advance display band

                  ;; Each display entry is nine bytes.  This code
                  ;; computes an offset into the display list based
                  ;; on the active display band and then sets up
                  ;; the data port so that the values may be read
                  ;; out using autoincrement.

                  LOAD s9, s8                         ; multiply display
                  SL0 s9                              ; band value by 9
                  SL0 s9                              ; to obtain index
                  SL0 s9                              ; into the display
                  ADD s9, s8                          ; list in buffer
                  LOAD sA, list_cptr_h                ; load hi byte of list
                  ADD s9, list_cptr_l                 ; add index to lo byte
                  ADDCY sA, zero                      ; adjust hi for carry
                  OUTPUT s9, pt_view_cptr_l           ; write to cptr_l
                  OUTPUT sA, pt_view_cptr_h           ; write to cptr_h
                  LOAD s9, zero                       ; clear these so that only
                  OUTPUT s9, pt_view_x_apos           ; view_size and view_cptr
                  OUTPUT s9, pt_view_y_apos           ; will set buffer address

                  ;; Basically a copy from display list in buffer to
                  ;; registers in the display controller.

                  INPUT s9, pt_view_access            ; read with autoinc
                  OUTPUT s9, pt_match_val_l           ; write match_val_l
                  INPUT s9, pt_view_access            ; read with autoinc
                  OUTPUT s9, pt_match_val_h           ; write match_val_h
                  LOAD s9, vmatch_ena_auto            ; trigger for next band
                  OUTPUT s9, pt_master_ctrl_h         ; write master_ctrl_h
                  INPUT s9, pt_view_access            ; read with autoinc
                  OUTPUT s9, pt_view_params           ; write view_params
                  INPUT s9, pt_view_access            ; read with autoinc
                  OUTPUT s9, pt_view_x_orig           ; write view_x_orig
                  INPUT s9, pt_view_access            ; read with autoinc
                  OUTPUT s9, pt_view_y_orig           ; write view_y_orig

                  ;; Only reload view_cptr and view_size after all
                  ;; data for the display list has been obtained.
                  ;; These registers affect the buffer addressing.

                  INPUT sB, pt_view_access            ; read with autoinc
                  INPUT sC, pt_view_access            ; read with autoinc
                  INPUT s9, pt_view_access            ; read with autoinc
                  INPUT sA, pt_view_access            ; read with autoinc
                  OUTPUT sB, pt_view_x_size           ; write view_x_size
                  OUTPUT sC, pt_view_y_size           ; write view_y_size
                  OUTPUT s9, pt_view_cptr_l           ; write to cptr_l
                  OUTPUT sA, pt_view_cptr_h           ; write to cptr_h
                  RETURNI ENABLE

;;============================================================================
;; Control processing done during interrupt service routine.  This needs
;; to be called before the band update, because it trounces the picotext
;; state.  When the band update follows this, the picotext state is set
;; again to the desired values.
;;============================================================================

   process_ctrls: INPUT s9, led_stat                  ; get led status
                  ADD s9, one                         ; running counter
                  OUTPUT s9, led_stat                 ; blinken, dude!
                  INPUT s9, rot_stat                  ; check knob status
                  TEST s9, rot_stat_dn                ; look for knob press
                  JUMP Z, do_context                  ; if not, process others
     new_context: ADD sF, one                         ; increment context state
                  AND sF, control_mask                ; implement state roll
      do_context: LOAD s9, zero                       ; want offset from cptr zero
                  OUTPUT s9, pt_view_x_apos           ; write to address position
                  OUTPUT s9, pt_view_y_apos           ; so offset from cptr is set
                  LOAD s9, list_cptr_l                ; take the display list
                  LOAD sA, list_cptr_h                ; pointer and add the
                  ADD s9, b6_cptr_offset              ; offset to reach b6
                  ADDCY sA, zero                      ; text string pointer
                  OUTPUT s9, pt_view_cptr_l           ; load picotext cptr
                  OUTPUT sA, pt_view_cptr_h           ; with computed address
           tupd0: COMPARE sF, control_state0          ; check control state
                  JUMP NZ, tupd1                      ; if not, try another
                  LOAD s9, band6a_cptr_l              ; set correct text
                  LOAD sA, band6a_cptr_h              ; via display list
           tupd1: COMPARE sF, control_state1          ; check control state
                  JUMP NZ, tupd2                      ; if not, try another
                  LOAD s9, band6b_cptr_l              ; set correct text
                  LOAD sA, band6b_cptr_h              ; via dispaly list
           tupd2: COMPARE sF, control_state2          ; check control state
                  JUMP NZ, tupd3                      ; if not, try another
                  LOAD s9, band6c_cptr_l              ; set correct text
                  LOAD sA, band6c_cptr_h              ; via display list
           tupd3: COMPARE sF, control_state3          ; check control state
                  JUMP NZ, tupdx                      ; if not, do update
                  LOAD s9, band6d_cptr_l              ; set correct text
                  LOAD sA, band6d_cptr_h              ; via display list
           tupdx: OUTPUT s9, pt_view_access           ; write out the text
                  OUTPUT sA, pt_view_access           ; string address
          mbnupd: LOAD s9, zero                       ; want offset from cptr zero
                  OUTPUT s9, pt_view_x_apos           ; write to address position
                  OUTPUT s9, pt_view_y_apos           ; so offset from cptr is set
                  LOAD s9, band6d_cptr_l              ; take the display list
                  LOAD sA, band6d_cptr_h              ; pointer and add the
                  ADD s9, b6d_num_offset              ; offset to reach b6
                  ADDCY sA, zero                      ; text string pointer
                  OUTPUT s9, pt_view_cptr_l           ; load picotext cptr
                  OUTPUT sA, pt_view_cptr_h           ; with computed address
                  LOAD s9, s7                         ; copy in multiboot num
                  ADD s9, ascii_adj                   ; adjust to ascii
                  OUTPUT s9, pt_view_access           ; write out the char
            upd0: COMPARE sF, control_state0          ; check for cs0
                  JUMP NZ, upd1                       ; if not, try next
                  CALL kill_auto                      ; should auto die?
                  CALL scroll_img                     ; in cs0, btns scroll
                  CALL rotate_img                     ; in cs0, knob rotate
            upd1: COMPARE sF, control_state1          ; check for cs1
                  JUMP NZ, upd2                       ; if not, try next
                  CALL kill_auto                      ; should auto die?
                  CALL scroll_img                     ; in cs1, btns scroll
                  CALL scale_img                      ; in cs1, knob scales
            upd2: COMPARE sF, control_state2          ; check for cs2
                  JUMP NZ, upd3                       ; if not, try next
                  CALL engage_auto                    ; in cs2, btns engage
                  CALL adjust_vol                     ; in cs2, knob volume
            upd3: COMPARE sF, control_state3          ; check for cs3
                  JUMP NZ, ctrls_done                 ; if not, ctrls done
                  CALL execute_mb                     ; in cs3, btns reboot
                  CALL select_mb                      ; in cs3, knob select
      ctrls_done: CALL do_auto                        ; do the autopilot
       updaterzm: OUTPUT sF, rot_stat                 ; clear the knob status
                  INPUT s9, rz_dx_frc_ms              ; copy rz_dx_frc_ms
                  OUTPUT s9, rz_xdel_frc_ms           ; to rz_xdel_frc_ms
                  INPUT s9, rz_dx_int_ls              ; copy rx_dx_int_ls
                  OUTPUT s9, rz_xdel_int_ls           ; to rz_xdel_int_ls
                  INPUT s9, rz_dy_frc_ms              ; copy rz_dy_frc_ms
                  OUTPUT s9, rz_ydel_frc_ms           ; to rz_ydel_frc_ms
                  INPUT s9, rz_dy_int_ls              ; copy rz_dy_int_ls
                  OUTPUT s9, rz_ydel_int_ls           ; to rz_ydel_int_ls
       updateaud: LOAD s9, one                        ; ena if not already
                  OUTPUT s9, audio_enable             ; write to hardware
                  INPUT s9, auto_flag                 ; check autopilot
                  TEST s9, auto_lcddone               ; showing welcome?
                  RETURN Z                            ; don't change loop
                  INPUT s9, audio_stat                ; get status bits
                  AND s9, audio_rand_msk              ; obtain 4-bit rand
                  COMPARE s9, audio_novoxpct          ; compare to thresh
                  JUMP C, vox_off                     ; s9 lte pct is off
          vox_on: LOAD sA, audio_novox                ; load novox bit value
                  XOR sA, minus_one                   ; invert it for mask
                  INPUT s9, audio_loop                ; get loop value
                  AND s9, sA                          ; select vox loop
                  JUMP vox_upd                        ; go do update
         vox_off: INPUT s9, audio_loop                ; get loop value
                  OR s9, audio_novox                  ; select novox loop
         vox_upd: AND s9, 03                          ; mask any message
                  OUTPUT s9, audio_loop               ; write to loop sel
                  RETURN                              ; done with update

         do_auto: INPUT s9, auto_flag                 ; obtain auto status
                  TEST s9, auto_lcddone               ; is welcome done?
                  JUMP NZ, pilot                      ; skip next if done
                  ADD s9, one                         ; increment count
                  OUTPUT s9, auto_flag                ; write back
           pilot: TEST s9, auto_flag_on               ; is it on?
                  RETURN Z                            ; if not, exit
                  INPUT s9, auto_data                 ; read data
                  AND s9, 03                          ; two bits used
                  CALL ascale                         ; scale accordingly
                  INPUT s9, auto_data                 ; read data
                  SR0 s9                              ; shift right
                  SR0 s9                              ; shift right
                  AND s9, 03                          ; two bits used
                  CALL arotate                        ; rotate accordingly
                  INPUT s6, auto_data                 ; read data
                  SR0 s6                              ; shift right
                  SR0 s6                              ; shift right
                  SR0 s6                              ; shift right
                  SR0 s6                              ; shift right
                  AND s6, 0F                          ; four bits used
                  CALL ascroll                        ; scroll accordingly
                  INPUT s9, auto_addr_h               ; get high addr
                  SR0 s9                              ; get msbs only
                  AND s9, one                         ; mask all but one
                  OUTPUT s9, rz_clutmode              ; use as imgsel
                  INPUT s9, auto_addr_l               ; get low addr
                  INPUT sA, auto_addr_h               ; get high addr
                  ADD s9, one                         ; increment the
                  ADDCY sA, zero                      ; 16-bit addr
                  OUTPUT s9, auto_addr_l              ; write hardware
                  OUTPUT sA, auto_addr_h              ; write hardware
                  RETURN                              ; done here

     engage_auto: INPUT s9, btn_stat                  ; read button status
                  TEST s9, 0F                         ; any buttons pressed?
                  RETURN Z                            ; if not, return
                  LOAD s9, zero                       ; clear out the position
                  OUTPUT s9, rz_xpos_frc_ms           ; write to register
                  OUTPUT s9, rz_xpos_int_ls           ; write to register
                  OUTPUT s9, rz_xpos_int_ms           ; write to register
                  OUTPUT s9, rz_ypos_frc_ms           ; write to register
                  OUTPUT s9, rz_ypos_int_ls           ; write to register
                  OUTPUT s9, rz_ypos_int_ms           ; write to register
                  OUTPUT s9, auto_addr_l              ; write to register
                  OUTPUT s9, auto_addr_h              ; write to register
                  LOAD s9, rz_angle_rst               ; load default angle
                  OUTPUT s9, rz_angle                 ; and write to rzoom
                  LOAD s9, rz_step_rst                ; load default step
                  OUTPUT s9, rz_step                  ; and write to rzoom
                  INPUT s9, auto_flag                 ; get register
                  OR s9, auto_flag_on                 ; autopilot on
                  OUTPUT s9, auto_flag                ; write to register
                  LOAD s9, audio_loop_1a              ; auto mode bgm
                  OUTPUT s9, audio_loop               ; write to hardware
                  RETURN                              ; done with this

       kill_auto: INPUT s9, btn_stat                  ; read button status
                  TEST s9, 0F                         ; any buttons pressed?
                  JUMP NZ, iubeo_valere               ; I bid you farewell
                  INPUT s9, rot_stat                  ; read knob status
                  TEST s9, 03                         ; any knob turns?
                  JUMP NZ, iubeo_valere               ; bid you farewell
                  RETURN                              ; done with this
    iubeo_valere: INPUT s9, auto_flag                 ; get the flag status
                  TEST s9, auto_flag_on               ; is it currently on?
                  RETURN Z                            ; already off, done...
                  LOAD sA, auto_flag_on               ; get the bit value
                  XOR sA, minus_one                   ; invert for mask
                  AND s9, sA                          ; mask off enabled
                  OUTPUT s9, auto_flag                ; write to register
                  LOAD s9, audio_loop_2a              ; manual mode bgm
                  OUTPUT s9, audio_loop               ; write to hardware
                  RETURN                              ; done with this

       select_mb: INPUT s9, rot_stat                  ; get knob status
                  TEST s9, rot_stat_rt                ; check for right
                  JUMP Z, mb_no_rt                    ; if not, check left
                  ADD s7, one                         ; right means inc
                  COMPARE s7, mb_max                  ; between min and max
                  JUMP C, mb_no_rt                    ; carry means in range
                  LOAD s7, mb_max                     ; otherwise load max
        mb_no_rt: TEST s9, rot_stat_lt                ; check for left
                  JUMP Z, mb_no_lt                    ; if not, exit
                  SUB s7, one                         ; left means dec
                  COMPARE s7, one                     ; between min and max
                  JUMP NC, mb_no_lt                   ; no carry is in range
                  LOAD s7, one                        ; otherwise load min
        mb_no_lt: RETURN                              ; done with this

      execute_mb: INPUT s9, btn_stat                  ; read button status
                  TEST s9, 0F                         ; any buttons pressed?
                  JUMP NZ, reboot                     ; if so, we'll reboot
                  INPUT s9, rs232dce_stat             ; obtain dce fifo stat
                  TEST s9, rs232dce_rxpres            ; check rxpres true
                  RETURN Z                            ; if empty, done
                  INPUT s9, rs232dce_data             ; read byte out
                  SUB s9, ascii_adj                   ; adjust from ascii
                  COMPARE s9, one                     ; check lower than min
                  RETURN C                            ; carry means lt min
                  SUB s9, one                         ; adjust by one
                  COMPARE s9, mb_max                  ; check lower than max+1
                  RETURN NC                           ; no carry means gt max+1
                  ADD s9, one                         ; remove adjustment
                  LOAD s7, s9                         ; copy in to s7
                  ;; The following sequence is "terminal" and
                  ;; for this reason I don't need to preserve
                  ;; any register state.  Leave everything in
                  ;; a cleaned up condition for the next app.
         reboot:  DISABLE INTERRUPT                   ; turn off interrupts
                  INPUT s9, pt_master_ctrl_l          ; get master_ctrl_l
                  LOAD sA, disp_dis_msk               ; get disable mask
                  XOR sA, minus_one                   ; invert it
                  OR s9, sA                           ; set disable bit
                  OUTPUT s9, pt_master_ctrl_l         ; write result
                  CALL lcd_reset_8bit                 ; leave lcd blank
                  CALL clear_dce                      ; wipe out terminal
                  LOAD s9, one                        ; load cfg settings
                  OUTPUT s9, mb_mode                  ; output to port
                  LOAD s9, mb_cfg_vsel                ; load cfg settings
                  OUTPUT s9, mb_vsel                  ; output to port
                  LOAD s9, zero                       ; load cfg settings
                  OUTPUT s9, mb_iuse                  ; output to port
                  LOAD s9, mb_cfg_ad_hh               ; load cfg settings
                  OUTPUT s9, mb_ad_hh                 ; output to port
                  LOAD s9, mb_cfg1_ad_ll              ; load cfg1 settings
                  OUTPUT s9, mb_ad_ll                 ; output to port
                  LOAD s9, mb_cfg1_ad_ml              ; load cfg1 settings
                  OUTPUT s9, mb_ad_ml                 ; output to port
                  LOAD s9, mb_cfg1_ad_mh              ; load cfg1 settings
                  OUTPUT s9, mb_ad_mh                 ; output to port
                  SUB s7, one                         ; test for value
                  JUMP Z, mbstrb                      ; if match, reboot
                  LOAD s9, mb_cfg2_ad_ll              ; load cfg2 settings
                  OUTPUT s9, mb_ad_ll                 ; output to port
                  LOAD s9, mb_cfg2_ad_ml              ; load cfg2 settings
                  OUTPUT s9, mb_ad_ml                 ; output to port
                  LOAD s9, mb_cfg2_ad_mh              ; load cfg2 settings
                  OUTPUT s9, mb_ad_mh                 ; output to port
                  SUB s7, one                         ; test for value
                  JUMP Z, mbstrb                      ; if match, reboot
                  LOAD s9, mb_cfg3_ad_ll              ; load cfg3 settings
                  OUTPUT s9, mb_ad_ll                 ; output to port
                  LOAD s9, mb_cfg3_ad_ml              ; load cfg3 settings
                  OUTPUT s9, mb_ad_ml                 ; output to port
                  LOAD s9, mb_cfg3_ad_mh              ; load cfg3 settings
                  OUTPUT s9, mb_ad_mh                 ; output to port
                  SUB s7, one                         ; test for value
                  JUMP Z, mbstrb                      ; if match, reboot
                  LOAD s9, mb_cfg4_ad_ll              ; load cfg4 settings
                  OUTPUT s9, mb_ad_ll                 ; output to port
                  LOAD s9, mb_cfg4_ad_ml              ; load cfg4 settings
                  OUTPUT s9, mb_ad_ml                 ; output to port
                  LOAD s9, mb_cfg4_ad_mh              ; load cfg4 settings
                  OUTPUT s9, mb_ad_mh                 ; output to port
                  SUB s7, one                         ; test for value
                  JUMP Z, mbstrb                      ; if match, reboot
                  JUMP hang                           ; if not, error, hang
          mbstrb: OUTPUT s9, mb_strobe                ; kick off reboot
            hang: JUMP hang                           ; game over, pal

      scroll_img: INPUT s6, btn_stat                  ; read button status
                  CALL ascroll                        ; speed up hack
                  CALL ascroll                        ; speed up hack
                  CALL ascroll                        ; speed up hack
                  CALL ascroll                        ; speed up hack
                  RETURN                              ; done with this
         ascroll: TEST s6, btn_stat_e                 ; check for button e
                  JUMP Z, check_w                     ; skip if not pressed
                  CALL dx_to_sEsDsC                   ; load dx
                  CALL xpos_to_sBsAs9                 ; load xpos
                  CALL a_sEsDsC_sBsAs9                ; add dx to xpos
                  CALL sBsAs9_to_xpos                 ; store xpos
                  CALL dy_to_sEsDsC                   ; load dy
                  CALL ypos_to_sBsAs9                 ; load ypos
                  CALL a_sEsDsC_sBsAs9                ; add dy to ypos
                  CALL sBsAs9_to_ypos                 ; store ypos
         check_w: TEST s6, btn_stat_w                 ; check for button w
                  JUMP Z, check_n                     ; skip if not pressed
                  CALL dx_to_sEsDsC                   ; load dx
                  CALL xpos_to_sBsAs9                 ; load xpos
                  CALL s_sEsDsC_sBsAs9                ; add -dx to xpos
                  CALL sBsAs9_to_xpos                 ; store xpos
                  CALL dy_to_sEsDsC                   ; load dy
                  CALL ypos_to_sBsAs9                 ; load ypos
                  CALL s_sEsDsC_sBsAs9                ; add -dy to ypos
                  CALL sBsAs9_to_ypos                 ; store ypos
         check_n: TEST s6, btn_stat_n                 ; check for button n
                  JUMP Z, check_s                     ; skip if not pressed
                  CALL dy_to_sEsDsC                   ; load dy
                  CALL xpos_to_sBsAs9                 ; load xpos
                  CALL s_sEsDsC_sBsAs9                ; add -dy to xpos
                  CALL sBsAs9_to_xpos                 ; store xpos
                  CALL dx_to_sEsDsC                   ; load dx
                  CALL ypos_to_sBsAs9                 ; load ypos
                  CALL a_sEsDsC_sBsAs9                ; add dx to ypos
                  CALL sBsAs9_to_ypos                 ; store ypos
         check_s: TEST s6, btn_stat_s                 ; check for button s
                  JUMP Z, scr_done                    ; skip if not pressed
                  CALL dy_to_sEsDsC                   ; load dy
                  CALL xpos_to_sBsAs9                 ; load xpos
                  CALL a_sEsDsC_sBsAs9                ; add dy to xpos
                  CALL sBsAs9_to_xpos                 ; store xpos
                  CALL dx_to_sEsDsC                   ; load dx
                  CALL ypos_to_sBsAs9                 ; load ypos
                  CALL s_sEsDsC_sBsAs9                ; add -dx to ypos
                  CALL sBsAs9_to_ypos                 ; store ypos
        scr_done: RETURN                              ; done with this

    dx_to_sEsDsC: INPUT sC, rz_dx_frc_ms              ; dump this from hw
                  INPUT sD, rz_dx_int_ls              ; dump this from hw
                  INPUT sE, rz_dx_int_ls              ; dump this from hw
                  JUMP delta_extend                   ; now sign extend
    dy_to_sEsDsC: INPUT sC, rz_dy_frc_ms              ; dump this from hw
                  INPUT sD, rz_dy_int_ls              ; dump this from hw
                  INPUT sE, rz_dy_int_ls              ; dump this from hw
    delta_extend: SRX sE                              ; sign extend by
                  SRX sE                              ; shifting right
                  SRX sE                              ; seven times
                  SRX sE                              ; end result is
                  SRX sE                              ; sE has 8 bits of
                  SRX sE                              ; the msb from the
                  SRX sE                              ; data in reg sD
                  RETURN                              ; done with this

  xpos_to_sBsAs9: INPUT s9, rz_xpos_frc_ms            ; dump this from hw
                  INPUT sA, rz_xpos_int_ls            ; dump this from hw
                  INPUT sB, rz_xpos_int_ms            ; dump this from hw
                  RETURN                              ; done with this

  ypos_to_sBsAs9: INPUT s9, rz_ypos_frc_ms            ; dump this from hw
                  INPUT sA, rz_ypos_int_ls            ; dump this from hw
                  INPUT sB, rz_ypos_int_ms            ; dump this from hw
                  RETURN                              ; done with this

 a_sEsDsC_sBsAs9: ADD s9, sC                          ; initial add
                  ADDCY sA, sD                        ; add with carry
                  ADDCY sB, sE                        ; add with carry
                  RETURN                              ; done with this

 s_sEsDsC_sBsAs9: SUB s9, sC                          ; initial subtract
                  SUBCY sA, sD                        ; subtract with borrow
                  SUBCY sB, sE                        ; subtract with borrow
                  RETURN                              ; done with this

  sBsAs9_to_xpos: OUTPUT s9, rz_xpos_frc_ms           ; dump this to hw
                  OUTPUT sA, rz_xpos_int_ls           ; dump this to hw
                  OUTPUT sB, rz_xpos_int_ms           ; dump this to hw
                  RETURN                              ; done with this

  sBsAs9_to_ypos: OUTPUT s9, rz_ypos_frc_ms           ; dump this to hw
                  OUTPUT sA, rz_ypos_int_ls           ; dump this to hw
                  OUTPUT sB, rz_ypos_int_ms           ; dump this to hw
                  RETURN                              ; done with this

      rotate_img: INPUT s9, rot_stat                  ; get knob status
                  INPUT sA, rz_angle                  ; read the current angle
                  LOAD sB, manu_rot_step              ; set step for manual
                  JUMP rot_ck_lt                      ; do it
         arotate: INPUT sA, rz_angle                  ; read the current angle
                  LOAD sB, auto_rot_step              ; set step for auto
                  JUMP rot_ck_lt                      ; do it
       rot_ck_lt: TEST s9, rot_stat_lt                ; check for lt turn
                  JUMP Z, rot_no_lt                   ; if not, check rt
                  SUB sA, sB                          ; dec angle, image ccw
       rot_no_lt: TEST s9, rot_stat_rt                ; check for rt turn
                  JUMP Z, rot_no_rt                   ; if not, wrap up
                  ADD sA, sB                          ; inc angle, image cw
       rot_no_rt: OUTPUT sA, rz_angle                 ; write to angle register
                  RETURN                              ; done with this

       scale_img: INPUT s9, rot_stat                  ; get knob status
                  CALL ascale                         ; speed up hack
                  CALL ascale                         ; speed up hack
                  CALL ascale                         ; speed up hack
                  CALL ascale                         ; speed up hack
                  CALL ascale                         ; speed up hack
                  CALL ascale                         ; speed up hack
                  RETURN                              ; done with this
          ascale: INPUT sA, rz_step                   ; read the current step
                  INPUT sB, rz_step                   ; save a copy
       scl_ck_lt: TEST s9, rot_stat_lt                ; check for lt turn
                  JUMP Z, scl_no_lt                   ; if not, check rt
                  ADD sA, one                         ; inc step, img smaller
       scl_no_lt: TEST s9, rot_stat_rt                ; check for rt turn
                  JUMP Z, scl_no_rt                   ; if not, wrap up
                  SUB sA, one                         ; dec step, img larger
       scl_no_rt: COMPARE sA, zero                    ; is new step invalid?
                  JUMP NZ, scl_around                 ; if not, go update it
                  LOAD sA, sB                         ; if so, restore previous
      scl_around: OUTPUT sA, rz_step                  ; write to step register
                  RETURN                              ; done with this

      adjust_vol: INPUT s9, rot_stat                  ; get knob status
                  INPUT sA, audio_volume              ; read the current volume
                  INPUT sB, audio_volume              ; save a copy
       vol_ck_lt: TEST s9, rot_stat_lt                ; check for lt turn
                  JUMP Z, vol_no_lt                   ; if not, check rt
                  SUB sA, one                         ; dec volume, vol down
       vol_no_lt: TEST s9, rot_stat_rt                ; check for rt turn
                  JUMP Z, vol_no_rt                   ; if not, wrap up
                  ADD sA, one                         ; inc volume, vol up
       vol_no_rt: COMPARE sA, minus_one               ; is new volume invalid?
                  JUMP Z, vol_restore                 ; if so, restore
     vol_nextchk: COMPARE sA, 08                      ; is new volume invalid?
                  JUMP NZ, vol_around                 ; if not, update
     vol_restore: LOAD sA, sB                         ; if so, restore previous
      vol_around: OUTPUT sA, audio_volume             ; write to volume register
                  RETURN                              ; done with this

;;============================================================================
;; Routines for serial transmission.  These use s0 for parameter passing
;; and return, and use s1 and s2 as scratch for temporary storage.  Note
;; these may block execution for considerable time depending on fifo state.
;;============================================================================

       tx_to_dce: INPUT s1, rs232dce_stat             ; obtain fifo status
                  TEST s1, rs232dce_txfull            ; check txfull true
                  JUMP NZ, tx_to_dce                  ; if full, sit and spin
                  OUTPUT s0, rs232dce_data            ; write data to fifo
                  RETURN                              ; all done

       rx_fm_dce: INPUT s1, rs232dce_stat             ; obtain fifo status
                  TEST s1, rs232dce_rxpres            ; check rxpres true
                  JUMP Z, rx_fm_dce                   ; if empty, sit and spin
                  INPUT s0, rs232dce_data             ; read data from fifo
                  RETURN                              ; all done

       clear_dce: LOAD s2, terminal_lines             ; num of terminal lines
           cloop: LOAD s0, ascii_CR                   ; load data
                  CALL tx_to_dce                      ; send it
                  SUB s2, one                         ; decrement loop
                  JUMP NZ, cloop                      ; jump back for more
           cwait: INPUT s1, rs232dce_stat             ; obtain fifo status
                  TEST s1, rs232dce_txpres            ; check txpres true
                  JUMP NZ, cwait                      ; get it all out
                  RETURN                              ; all done

;;============================================================================
;; Delay routines.  These use s0 through s3 to implement a counter.  The
;; larger the delay, the more registers consumed.
;;============================================================================

       delay_1us: LOAD s0, delay_1us_const
        wait_1us: SUB s0, one
                  JUMP NZ, wait_1us
                  RETURN
      delay_40us: LOAD s1, 28                         ; 40 x 1us = 40us
       wait_40us: CALL delay_1us
                  SUB s1, one
                  JUMP NZ, wait_40us
                  RETURN
       delay_1ms: LOAD s2, 19                         ; 25 x 40us = 1ms
        wait_1ms: CALL delay_40us
                  SUB s2, one
                  JUMP NZ, wait_1ms
                  RETURN
      delay_20ms: LOAD s3, 14                         ; 20 x 1ms = 20ms
       wait_20ms: CALL delay_1ms
                  SUB s3, one
                  JUMP NZ, wait_20ms
                  RETURN

;;============================================================================
;; lcd_reset_8bit
;;============================================================================

                  ;; Reset and initialize display in 8-bit mode.
                  ;;
                  ;; Requires 4-bit instructions 3, 3, 3 to be sent
                  ;; with delays followed by the instructions to set up
                  ;; the display.  Registers used: s0, s1, s2, s3, s4.
                  ;;
  lcd_reset_8bit: LOAD s0, zero                       ; clear value
                  OUTPUT s0, lcd_dout                 ; clear dout
                  OUTPUT s0, lcd_ctrl                 ; clear ctrl
                  CALL delay_20ms                     ; wait >15ms
                  LOAD s4, 30
                  CALL lcd_write_reg                  ; send '3X'
                  CALL delay_20ms                     ; wait >4.1ms
                  LOAD s4, 30
                  CALL lcd_write_reg                  ; send '3X'
                  CALL delay_1ms                      ; wait >100us
                  LOAD s4, 30
                  CALL lcd_write_reg                  ; send '3X'
                  CALL delay_40us                     ; wait >40us
                  ;;
                  ;; Function set = 0 0 1 W N F X X where:
                  ;; W = interface width, 1 --> 8 bit, 0 --> 4 bit
                  ;; N = number of lines, 1 --> 2 lines, 0 -- > 1 line
                  ;; F = font size, 1 --> 5x11, 0 --> 5x7
                  ;; X = don't care, use zero
                  ;;
                  ;; To set up the display in 4-bit mode, we want:
                  ;; W = 1, N = 1, F = 0 --> Function set = 38h
                  ;;
                  LOAD s5, 38                         ; function set
                  CALL reg8_as_8bit
                  ;;
                  ;; Entry Mode set = 0 0 0 0 1 I S
                  ;; I = increment, 1 --> increment, 0 --> no increment
                  ;; S = shift, 1 --> shift, 0 --> no shift
                  ;;
                  ;; To set up increment but not shift, we want:
                  ;; I = 1, S = 0 --> Entry Mode set = 06h
                  ;;
                  LOAD s5, 06                         ; entry mode
                  CALL reg8_as_8bit
                  ;;
                  ;; Display Control set = 0 0 0 0 1 D C B
                  ;; D = display on, 1 --> on, 0 --> off
                  ;; C = cursor on, 1 --> on, 0 --> off
                  ;; B = cursor blink, 1 --> on, 0 --> off
                  ;;
                  ;; To turn on the display with no cursor, we want:
                  ;; D = 1, C = 0, B = 0 --> Display Control set = 0Ch
                  ;;
                  LOAD s5, 0C                         ; display control
                  CALL reg8_as_8bit
                  ;;
                  ;; Display Clear command = 01h
                  ;;
                  LOAD s5, 01                         ; display clear
                  CALL reg8_as_8bit
                  CALL delay_1ms                      ; wait >1.64ms
                  CALL delay_1ms
                  ;;
                  RETURN

;;============================================================================
;; Subroutine to pulse the enable for greater than 230 ns.  Assumes s4
;; contains the current state of the lcd control port.
;;============================================================================

     lcd_pulse_e: XOR s4, lcd_e                       ; toggle E
                  OUTPUT s4, lcd_ctrl
                  CALL delay_1us
                  XOR s4, lcd_e                       ; toggle E
                  OUTPUT s4, lcd_ctrl
                  RETURN

;;============================================================================
;; Subroutine to perform a reg write.  Data is passed through s4.
;;============================================================================

   lcd_write_reg: OUTPUT s4, lcd_dout                 ; write data
                  LOAD s4, zero                       ; RS = 0, RW = 0, E = 0
                  CALL lcd_pulse_e                    ; strobe upper nibble
                  LOAD s4, zero                       ; clear value
                  OUTPUT s4, lcd_dout                 ; clear dout
                  OUTPUT s4, lcd_ctrl                 ; clear ctrl
                  RETURN

;;============================================================================
;; Subroutine to perform a ram write.  Data is passed through s4.
;;============================================================================

   lcd_write_ram: OUTPUT s4, lcd_dout                 ; write data
                  LOAD s4, 04                         ; RS = 1, RW = 0, E = 0
                  CALL lcd_pulse_e                    ; strobe upper nibble
                  LOAD s4, zero                       ; clear value
                  OUTPUT s4, lcd_dout                 ; clear dout
                  OUTPUT s4, lcd_ctrl                 ; clear ctrl
                  RETURN

;;============================================================================
;; reg8_as_8bit
;;============================================================================

                  ;; The 8-bit instruction should be provided in register s5.
                  ;; Instructions are written using the following sequence:
                  ;;
                  ;; Complete byte
                  ;; wait >40us
                  ;;
                  ;; Registers used s0, s1, s4, s5

    reg8_as_8bit: LOAD s4, s5                         ; copy data into s4
                  CALL lcd_write_reg                  ; write complete byte
                  CALL delay_40us                     ; wait >40us
                  RETURN

;;============================================================================
;; ram8_as_8bit
;;============================================================================

                  ;; The 8-bit data should be provided in register s5.
                  ;; Instructions are written using the following sequence:
                  ;;
                  ;; Complete byte
                  ;; wait >40us
                  ;;
                  ;; Registers used s0, s1, s4, s5

    ram8_as_8bit: LOAD s4, s5                         ; copy data into s4
                  CALL lcd_write_ram                  ; write complete byte
                  CALL delay_40us                     ; wait >40us
                  RETURN

;;============================================================================
;; lcd_cursor8
;;============================================================================

                  ;; Position the cursor ready for characters to be written.
                  ;; The display is formed of 2 lines of 16 characters and each
                  ;; position has a corresponding address as indicated below.
                  ;;
                  ;;                   Character position
                  ;;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                  ;;
                  ;; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                  ;; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                  ;;
                  ;; This routine will set the cursor position using the value
                  ;; provided in register s5. The upper nibble will define the
                  ;; line and the lower nibble the character position on the
                  ;; line.
                  ;;
                  ;; Registers used s0, s1, s2, s3, s4

     lcd_cursor8: TEST s5, 10                         ; test for line 1
                  JUMP Z, sl2_8
                  AND s5, 0F                          ; make address in range
                  OR s5, 80                           ; 80 to 8F for line 1
                  CALL reg8_as_8bit                   ; instruction write
                  RETURN
           sl2_8: AND s5, 0F                          ; make address in range
                  OR s5, C0                           ; C0 to CF for line 2
                  CALL reg8_as_8bit                   ; instruction write
                  RETURN

;;============================================================================
;; Routines to print specific messages.
;;============================================================================

         lcd_pkx: LOAD s5, 10                         ; load cursor position
                  CALL lcd_cursor8                    ; set cursor position
                  LOAD s5, ascii_P                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_r                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_s                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_s                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_K                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_n                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_b                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, control_mask               ; get max cs value
                  SUB s5, sF                          ; sub current cs
                  ADD s5, 30                          ; add ascii num base
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_x                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  RETURN                              ; done with this

         lcd_fbm: LOAD s5, 20                         ; load cursor position
                  CALL lcd_cursor8                    ; set cursor position
                  LOAD s5, ascii_F                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_r                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_B                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_M                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_n                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_u                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  RETURN                              ; done with this

         lcd_blc: LOAD s5, 10                         ; load cursor position
                  CALL lcd_cursor8                    ; set cursor position
                  LOAD s5, ascii_B                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_n                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_s                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_COLON                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_L                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_a                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_d                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_C                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_f                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_g                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, s7                         ; get mb cfg number
                  ADD s5, 30                          ; add ascii num base
                  CALL ram8_as_8bit                   ; send character
                  RETURN                              ; done with this

         lcd_ssc: LOAD s5, 20                         ; load cursor position
                  CALL lcd_cursor8                    ; set cursor position
                  LOAD s5, ascii_S                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_p                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_i                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_n                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_COLON                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_S                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_l                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_c                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_C                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_f                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_g                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  RETURN                              ; done with this

       lcd_hello: LOAD s5, 10                         ; load cursor position
                  CALL lcd_cursor8                    ; set cursor position
                  LOAD s5, ascii_W                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_l                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_c                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_m                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_o                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_S                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_3                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_A                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_AMP                  ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, 20                         ; load cursor position
                  CALL lcd_cursor8                    ; set cursor position
                  LOAD s5, ascii_S                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_3                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_A                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_N                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_S                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_a                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_r                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_e                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_r                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_SPACE                ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_K                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_i                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  LOAD s5, ascii_t                    ; load character
                  CALL ram8_as_8bit                   ; send character
                  RETURN                              ; done with this

;;============================================================================
;; Interrupt service routine vector.
;;============================================================================

                  ADDRESS 3FF
                  JUMP isr_start

;;============================================================================
;;
;;============================================================================